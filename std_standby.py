import numpy as npimport pandas as pdimport matplotlib as mplimport matplotlib.pyplot as pltfrom datetime import datetimeimport mathpd.options.mode.chained_assignment = Nonedef data_preprocess(data):    '''    Preprocess data in order to calculate threshold    Input:        data: DataFrame        columns: [TimeStr, Ia]    Output:        data: DataFrame        columns: [time, Ia]    '''    data = data[['TimeStr', 'Ia']]    data.loc[:,'TimeStr'] = pd.to_datetime(data['TimeStr'])    data.reset_index(drop=True, inplace=True)#删除日期缺失值    # data.loc[data['Ia'] > 1000, 'Ia'] = -1    data.dropna(subset=['TimeStr'], inplace=True)    if len(data) == 0:        return data#处理日期重复    data.loc[:,'TimeStr']=pd.to_datetime(data['TimeStr'].apply(lambda x: datetime.strftime(x, format='%Y-%m-%d %H:%M:%S')))    data.drop_duplicates('TimeStr', inplace=True)    data.reset_index(drop=True, inplace=True)#日期补全    time_series = pd.date_range(data["TimeStr"].min(), data["TimeStr"].max(), freq='s')    ts = pd.DataFrame(time_series, columns=["time"])    data = data.merge(ts, how='right', left_on="TimeStr", right_on="time")    data.drop(['TimeStr'], axis=1, inplace=True)    data.sort_values(by='time', inplace=True)    data.reset_index(drop=True, inplace=True)    data['Ia'] = data['Ia'].rolling(window=5, min_periods=1, center=False).median()    data.fillna(-1, inplace=True)    data = data[['time', 'Ia']]    '''    data['time','Ia']    '''    return datadef  hampel(val_orig,k=5,t0=3):    vals=val_orig.loc[:,'Ia']    # Hampel Filter    L = 1.4826    rolling_median=vals.rolling(window=k,min_periods=1,center=True).median()    difference=np.abs(rolling_median-vals)    median_abs_deviation=difference.rolling(window=k,min_periods=1,center=False).median()    threshold=t0*L*median_abs_deviation    outlier_idx=difference>threshold    val_orig.loc[outlier_idx,'Ia']=rolling_median[outlier_idx]    val_orig.loc[:,'Ia'].fillna(-1,inplace=True)    val_orig = val_orig[['time', 'Ia']]    return val_origdef window_fun(k,data,low,flag=False):    if flag==True:        Data=data_preprocess(data)        # Data=hampel(Data)        Data = Data.drop(Data[Data['Ia'] <=low].index).reset_index(drop=True)  #删除-1 0    else:        Data=data    if len(Data)==0:        print('电流值全部小于%s' % low)        standby_Ia_max, standby_Ia_min, standby_Ia_median=0,0,0        return standby_Ia_max,standby_Ia_min,standby_Ia_median,Data    Data['no']=pd.Series(range(0,len(Data)))    Data['window_no']=Data['no']//(k*60)    Data['count']=1    Iamean=round(Data.groupby(['window_no'])['Ia'].mean().reset_index(drop=False),1)    Iamean=Iamean.rename(columns={"Ia":"Ia_mean"})    Iastd=round(Data.groupby(['window_no'])['Ia'].std().reset_index(drop=False),1)    Iastd=Iastd.rename(columns={"Ia": "Ia_std"})    Data=Data.merge(Iamean,how='left',on='window_no')    Data=Data.merge(Iastd,how='left',on='window_no')    #先按照std升序排列，再按照Ia_mean升序排列    Data_new=pd.DataFrame(Data.groupby(['Ia_std','Ia_mean'])['count'].sum().reset_index(drop=False))    index=Data_new['Ia_std']== Data_new.loc[Data_new['Ia_std'].values.argmin(),'Ia_std']    standby=Data_new.loc[index,'Ia_mean']    standby_Ia_max = round(standby.max(),2)    standby_Ia_min = round(standby.min(),2)    standby_Ia_median = round(standby.median(),2)    print(Data_new)    return standby_Ia_max,standby_Ia_min,standby_Ia_median,Datadef plot_fun(data, standby_Ia_max, standby_Ia_min,standby_Ia_median):    ax=plt.figure(figsize=(10,8),num=1)    plt.plot(data['Ia'],linewidth=0.5,color='coral',linestyle=':',marker='.',markersize=0.3)    plt.axhline(y=standby_Ia_max, linewidth=1.5, color='cornflowerblue')    plt.axhline(y=standby_Ia_min,linewidth=1.5,color='royalblue')    plt.axhline(y=standby_Ia_median, linewidth=1, color='gray')    #ax.savefig(output+'test1.png')    plt.show()def loop_fun(data, standby_Ia_median):    # 策略    j=0    global Ia_mean_list    Ia_mean_list=[standby_Ia_median]    if len(data)==0:        standby_Ia_max, standby_Ia_min, standby_Ia_median=0,0,0        plot_fun(data_plot, standby_Ia_max, standby_Ia_min, standby_Ia_median)        return standby_Ia_max, standby_Ia_min, standby_Ia_median, data    else:        while j<10:            j += 1            print('-'*15+'检索报告'+'-'*15)            print('='*10+'第%s次迭代' %j +'='*10)            data = data[['Ia','time']]            data_small = data[data['Ia'] < standby_Ia_median].reset_index(drop=True)            standby_Ia_max, standby_Ia_min, standby_Ia_median, data = window_fun(3, data_small, 0.1)            print('待机电流: %s' % standby_Ia_median)            plot_fun(data_plot, standby_Ia_max, standby_Ia_min, standby_Ia_median)            plt.show()            Ia_mean_list.append(standby_Ia_median)            if Ia_mean_list[j-1]<=Ia_mean_list[j] or Ia_mean_list[j]==0:  #待机电流出现0 是由于关机后突然开动导致的异常                Ia_mean_list.pop()                break        return standby_Ia_max, standby_Ia_min, standby_Ia_median, dataif __name__=="__main__":    # data=pd.read_csv(r'C:\Users\rongjin.wang\Desktop\10.15.203.11.csv')    # data=pd.read_csv(r'C:\Users\rongjin.wang\Desktop\10.8.182.61.csv')    # data = pd.read_csv(r'C:\Users\rongjin.wang\Desktop\10.9.129.93.csv')    # data = pd.read_csv(r'C:\Users\rongjin.wang\Desktop\10.9.129.78.csv')    #    # data = pd.read_csv(r'C:\Users\rongjin.wang\Desktop\10.9.130.99.csv')    # data = pd.read_csv(r'C:\Users\rongjin.wang\Desktop\10.9.130.110.csv')    # data = pd.read_csv(r'C:\Users\rongjin.wang\Desktop\10.9.129.79.csv')    # data = pd.read_csv(r'C:\Users\rongjin.wang\Desktop\10.19.129.38.csv')    #    # data = pd.read_csv(r'C:\Users\rongjin.wang\Desktop\10.9.129.167.csv')    # 等离子切割机    # data = pd.read_csv(r'C:\Users\rongjin.wang\Desktop\10.9.129.169_0802.csv')    data = pd.read_pickle(r'C:\Users\rongjin.wang\Desktop\10.9.129.97.pkl')    # data = pd.read_pickle(r'C:\Users\rongjin.wang\Desktop\10.9.129.94.pkl')    data_plot = data.copy()    standby_Ia_max, standby_Ia_min,standby_Ia_median,data=window_fun(10, data,0.1,flag=True)    standby_Ia_max, standby_Ia_min, standby_Ia_median, data=loop_fun(data,standby_Ia_median)    print(Ia_mean_list)